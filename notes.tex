% Notes about C-program
\documentclass[UTF8]{ctexart}

%\usepackage[dvipsnames]{xcolor}
\usepackage{listings,booktabs,caption,subcaption,amsmath}
\usepackage{framed,graphicx}
\lstset{
	basicstyle=\sffamily,
	keywordstyle=\bfseries,
	commentstyle=\rmfamily\itshape,
	stringstyle=\ttfamily,
	flexiblecolumns
}

\author{JC-Zhou}
\title{NOTES about \textit{C-Programs}}
\date{\today}

\begin{document}
	\maketitle
	
	\section{C环境设置}
	\subsection{本地环境设置}
	\begin{enumerate}
		\item \emph{文本编辑器}: \begin{itemize}
			\item Windows Notepad, OS Edit command, Brief, EMACS 和 Vim/ Vi.
			\item 创建的文件成为源文件，扩展名为 ``.c"。
		\end{itemize}
		\item \emph{C 编译器}：\begin{itemize}
			\item C语言编译器用于将源码编译成最终可执行的程序。
			\item 常用的编译器为GNU的C/C++编译器。
		\end{itemize}
	\end{enumerate}
	\begin{framed}
	\textbf{不同系统下安装GCC}：
		\begin{itemize}
			\item \textbf{UNIX/Linux}:\\
			\$ gcc -v
			\item \textbf{Windows}:\\安装MinGW\\修改环境变量，将系统变量Path中加入C:\textbackslash MinGw\textbackslash bin \\cmd 中输入命令 mingw-get install gcc 和mingw-get install g++
		\end{itemize}
	\end{framed}

	\clearpage
	\section{C 程序结构}
	\textbf{C 程序包括：}
	\begin{itemize}
		\item 预处理器指令
		\item 函数
		\item 变量
		\item 语句\& 表达式
		\item 注释
	\end{itemize}
	
	\textbf{编译、执行C 程序}
	\begin{enumerate}
		\item 编辑文件，保存为“.c”
		\item 打开命令提示符，进入文件所在目录
		\item gcc *.c 编译文件
		\item 生成a.exe文件（for  windoms）
		\item 执行a.exe
	\end{enumerate}

	\clearpage
	\section{C 基本语法}
	\textbf{C 的令牌 (Tokens)}\\C 程序由各种令牌组成，可以是\emph{关键字、标识符、变量、字符串值和符号}。
	
	\textbf{分号(“；”)}：\\分号：语句结束符。
	
	\textbf{注释}：\begin{itemize}
		\item 单行注释：“//”。
		\item 多行注释：“/* ... */”
	\end{itemize}
	
	\textbf{标识符}：\begin{itemize}
		\item 标识变量、函数、或者自定义项目。
		\item 以A-Z，a-z 或下划线\_ 开始
		\item 区分大小写
		\item 不允许出现标点字符，如：@,\$ 和\% 等。
	\end{itemize}

	\captionof{table}{关键字}
	\begin{tabular*}{\linewidth}{l|l}
		\toprule
		关键字 & 说明\\
		\midrule
		auto & 声明自动变量\\
		break & 跳出当前循环 \\
		case & 开关语句分支 \\
		char & 声明字符型变量或函数返回值类型\\
		const & 声明只读变量 \\
		continue & 结束当前循环，开始下一轮循环\\
		default & 开关语句中的“其他”分支\\
		do & 循环语句的循环体 \\
		double & 声明双精度浮点型变量或函数返回类型\\
		else & 条件语句否定分支(与if连用)\\
		enum & 声明枚举类型 \\
		extem & 声明变量是在其它文件或文本的其他位置定义\\
		float & 声明浮点型变量或函数返回值类型\\
		for & 循环语句 \\
		goto & 无条件跳转语句 \\
		if & 条件语句 \\
		int & 声明整型变量或函数 \\
		long & 声明长整型或函数返回值类型\\
		register & 声明寄存器类型 \\
		return & 子程序返回类型(可选是否带参数)\\
		short & 声明短整型变量或函数 \\
		signed & 声明有符号类型变量或函数 \\
		sizeof & 计算数据类型或变量长度(即所占字节数)\\
		static & 声明静态变量 \\
		struct & 声明结构体类型\\
		switch & 用于开关语句 \\
		typedef & 用于给数据类型起别名 \\
		unsigned & 声明无符号类型变量或函数 \\
		union & 声明共用体类型 \\
		void & 声明函数无返回值或无参数，声明无类型指针\\
		volatile & 说明变量在程序执行中可被隐含地改变\\
		while & 循环语句的循环条件\\
		\bottomrule
	\end{tabular*}
	\textbf{C99 新增关键字}
	\begin{framed}
		\begin{itemize}
			\item \_Bool
			\item \_Complex
			\item \_Imaginary
			\item inline
			\item restrict
		\end{itemize}
	\end{framed}

	\textbf{C 11 新增关键字}:
	\begin{framed}
		\begin{itemize}
			\item \_Alignas
			\item \_Alignof
			\item \_Atomic
			\item \_Generic
			\item \_Noreturn
			\item \_Static\_assert
			\item \_Thread\_local
		\end{itemize}
	\end{framed}

	\clearpage
	\section{C 数据类型}
	数据类型：声明不同类型的变量或函数的系统。\\变量的类型决定了变量的存储占用的空间，以及如何解释存储的位模式。
	\captionof{table}{数据类型}
	\begin{tabular*}{\linewidth}{l|l}
		\toprule
		类型 & 描述 \\
		\midrule
		基本类型 & 算术类型，包括:整数类型,浮点类型 \\
		枚举类型 & 算术类型，用于定义在程序中只能赋予其一定的离散整数值的变量\\
		void 类型 & 表明没有可用值\\
		派生类型 & 指针类型,数组类型,结构类型,共用体类型,函数类型\\
	\bottomrule
	\end{tabular*}
	\begin{framed}
		\textbf{Note:} 数组类型和结构类型统称为聚合类型；函数类型指的是函数返回值的类型。
	\end{framed}
	
	\subsection{整数类型}
	\captionof{table}{整数类型}
	\begin{tabular*}{\linewidth}{l|l|p{18em}}
		\toprule
		类型 & 存储大小 & 值范围 \\
		\midrule
		char & 1字节 & -128 到 127 或 0 到 255\\
		unsigned char & 1字节 & 0到255\\
		signed char & 1字节 & -128 到 127 \\
		int & 2 或 4 字节 & -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647\\
		unsigned int & 2 或 4 字节 & 0 到65,535 或 0 到 4,294,967,295\\
		short & 2 字节 & -32,768 到 32,767\\
		unsigned short & 2字节 & 0 到65,535\\
		long & 4 字节 & -2,147,483,648 到 2,147,483,647\\
		unsigned long & 4 字节 & 0 到 4,294,967,295\\
		\bottomrule
	\end{tabular*}
	
	\begin{framed}
		\textbf{Note:} \emph{sizeof} 可以获得对象或类型的存储字节大小，如：$sizeof(int) ->4$.
	\end{framed}

	\subsection{浮点类型}
	\captionof{table}{浮点类型}
	\begin{tabular*}{\linewidth}{l|l|l|l}
		\toprule
		类型 & 存储大小 & 值范围 & 精度\\
		\midrule
		float & 4 字节 & 1.2E-38 到 3.4E+38 & 6 位小数\\
		double & 8 字节 & 2.3E-308 到 1.7E+308 & 15 位小数\\
		long double & 16 字节 & 3.4E-4932 到 1.1E+493 & 19 位小数\\
		\bottomrule
	\end{tabular*}

	\subsection{void类型}
	\captionof{table}{void类型}
	\begin{tabular*}{\linewidth}{c|c|p{22em}}
		\toprule
		序号 & 类型 & 描述\\
		\midrule
		1 & 函数返回为空 & 很多函数不返回值，或者称返回为空\\
		2 & 函数参数为空 & 很多函数不接受任何参数，不带参数的函数可以接受一个void\\
		3 & 指针指向void & 类型为 void* 的指针代表对象的地址，而不是类型。如：内存分配函数 \textit{void* malloc(size\_t size)}; \textbf{返回指向void的指针，可以转化为如何数据类型}\\
		\bottomrule
	\end{tabular*}

	\begin{framed}
		\textbf{Notes:} \\\textbf{常见数据类型}\begin{itemize}
			\item \textbf{小数}：\\单精度常量：2.3f\\双精度常量：2.3，默认为双精度
			\item \textbf{字符型常量}：\\用单引号括起来：'a'...，还有转义字符 '\textbackslash n'，'\textbackslash t' 等
			\item \textbf{字符串常量}：\\ 用双引号括起来，保存多个字符
		\end{itemize}
		\textbf{数据类型转换}：当一个表达式存在不同类型的常量或变量时\\自动转换规则：\begin{itemize}
			\item \textbf{浮点数赋给整型}：浮点数小数部分舍去
			\item \textbf{整数赋给浮点型}：数值不变，被存储到相应的浮点型变量中
		\end{itemize}
		\textbf{强制类型转换}：\\ \emph{(类型说明符)(表达式)}
	\end{framed}

	\clearpage
	\section{C 变量}
	变量只不过是\textbf{程序可操作的存储区的名称}。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。
	\captionof{table}{几种变量类型}
	\begin{tabular*}{\linewidth}{l|l}
		\toprule
		类型 & 描述 \\
		\midrule
		char & 通常是一个字节（八位）。这是一个整数类型。\\
		int & 对机器而言，整数的最自然的大小\\
		float & 单精度浮点值。格式：1 位符号，8 位指数，23 位小数\\
		double & 双精度浮点值。格式：1 位符号，11 位指数， 52 位小数\\
		void & 类型缺失\\
		\bottomrule
	\end{tabular*}
	\textbf{C 中变量定义}：\\变量定义：告诉编译器在何处创建变量的存储，以及如何创建变量的存储，如：\textbf{int i,j,k;},可带初始值，如：\textbf{int d=3, b=4;}\\不带初始值的定义：带有静态存储持续时间的变量会被隐式初始化位NULL（所有字节的值都为0），其他所有变量的初始值是未定义的。
	
	\textbf{C 中的变量声明}：\\向编译器保证变量以指定的类型和名称存在，只在编译时有意义，在连接时编译器需要实际的变量声明。\\ \textbf{Two cases}: \begin{enumerate}
		\item 需要建立存储空间。如：int a 在声明的时候已建立存储空间
		\item 不需要建立存储空间，通过\textbf{extern}关键字声明变量名而不定义它。\textbf{Notes:}除非\textbf{extern}关键字，否则都是变量的定义。
	\end{enumerate}
	\textbf{Note}：如果需要在一个源文件中引用另外一个源文件中定义的变量，需要在被引用文件的变量声明前加上\textbf{extern}关键字。如：被引用文件中声明为：\textbf{extern int x;}
	
	\textbf{C 中的左值(Lvalues)和右值(Rvalues)}\begin{itemize}
		\item \textbf{左值(lvalue)}：指向内存位置的表达式被称为左值(lvalue)，可以出现在赋值号的左边和右边（变量）
		\item \textbf{右值(rvalue)}：存储在内存中某些地址的数值，不能对其进行赋值的表达式，只能出现在赋值号的右边。（数值型，如：20,5...）
	\end{itemize}

	\begin{framed}
		\textbf{NOTES:}\\ \textbf{声明与定义}：\begin{itemize}
			\item \textbf{声明}：\textbf{extern int a;} 
			\item \textbf{定义}：\textbf{int a; extern int a=0; int a=0;}
		\end{itemize} 
		声明不能直接使用，需要当以后才能使用，声明一般在被调用文件中采用。\\
		\textbf{左值，右值}：\begin{itemize}
			\item 需要保存数据，左值(lvalues)
			\item 需要读取数据，右值(rvalues)
		\end{itemize}
		\textbf{变量的内存寻址}：\begin{itemize}
			\item 内存寻址由大到小，变量越先定义，内存地址越大（Ubuntu 为越先定义的内存地址越小，未初始化的默认输出为0）
			\item 变量地址获取：\textbf{\&+变量名}
			\item 输出地址格式：\textbf{\%p}
		\end{itemize}
		\textbf{C99 中的布尔类型}：\\头文件 $<\textbf{stdbool.h}>$ 定义了\textbf{bool} 代表 \textbf{\_Bool}, true 代表1, false 代表 0。\\
		\textbf{全局变量和局部变量在内存中的区别}：\begin{itemize}
			\item 全局变量：保存在内存的全局存储区中，占用静态的存储单元
			\item 局部变量：保存在栈中，只在函数被调用才动态地为变量分配存储单元
			\item \textbf{内存的划分：}\begin{enumerate}
				\item \textbf{栈(stack)}:由编译器进行管理，自动分配和释放，存放函数调用过程中的各种参数、局部变量、返回值以及函数返回地址。
				\item \textbf{堆(heap)}:用于程序动态申请分配和释放空间。C语言中的malloc和free，c++中的new和delete均是堆中进行
				\item \textbf{全局（静态）存储区}：分为DATA段和BSS段。DATA段（全局初始化区）：存放初始化的全局变量和静态变量；BSS段（全局未初始化区）：存放未初始化的全局变量和静态变量。程序结束后自动释放。
				\item \textbf{文字常量区}：存放常量字符串，结束后由系统释放
				\item \textbf{程序代码区}：存放程序的二进制代码
			\end{enumerate}
		\end{itemize}
	\end{framed}
	
	\clearpage
	\section{C 常量}
	常量是在程序执行过程中不会改变的固定值，也叫\textbf{字面量}。\\
	常量可为：\textbf{整数常量}、\textbf{浮点常量}、\textbf{字符常量}、\textbf{字符串常量}和\textbf{枚举常量}。
	
	\textbf{整数常量}\begin{itemize}
		\item 可以是十进制、八进制或十六进制。
		\item \textbf{前缀}：\begin{enumerate}
			\item \textbf{十六进制}：0x 或 0X；
			\item \textbf{十进制}：无前缀默认；
			\item \textbf{八进制}：0。
		\end{enumerate}
		\item \textbf{后缀}：\begin{enumerate}
			\item \textbf{U} 或 \textbf{u}：无符号整数（unsigned）；
			\item \textbf{L} 或 \textbf{l}：长整数（长整数）；
			\item 或两者组合：无符号长整数。
		\end{enumerate}
	\end{itemize}

	\textbf{浮点常量}\\由整数部分，小数点，小数部分和指数部分组成。
	\begin{itemize}
		\item \textbf{小数形式}：包括整数部分，小数部分，或者两者；
		\item \textbf{指数部分}：包括小数点，指数，或者两者。
	\end{itemize}
	带符号指数由 e 或 E 引入。
	
	\textbf{字符常量}\\括在单引号，如：'a'可存储在\textbf{char}类型\begin{itemize}
		\item 普通的字符：'a'...;
		\item 一个转义序列：'\textbackslash t';
		\item 一个通用的字符：'\textbackslash u02C0'.
	\end{itemize}

	\textbf{字符常量}：
	\captionof{table}{转义序列码}
	\begin{tabular*}{\linewidth}{l|l}
		\toprule
		转义序列 & 含义\\
		\midrule
		\textbackslash \textbackslash & \textbackslash 字符 \\
		\textbackslash' & ' 字符 \\
		\textbackslash" & " 字符\\
		\textbackslash ? & ? 字符 \\
		\textbackslash a & 警报铃声 \\
		\textbackslash b & 退格键 \\
		\textbackslash f & 换页符 \\
		\textbackslash n & 换行符 \\
		\textbackslash r & 回车 \\
		\textbackslash t & 水平制表符 \\
		\textbackslash v & 垂直制表符 \\
		\textbackslash ooo & 一到三位的八进制 \\
		\textbackslash xhh... & 一个或多个数字的十六进制数\\
		\bottomrule
	\end{tabular*}

	\textbf{字符串常量}：\\括在双引号\verb|""|中，包括：普通的字符，转义序列和通用的字符。\\可用空格做分隔符。
	
	\textbf{定义常量}：\\ 两种定义常量的方式：\begin{enumerate}
		\item 使用\textbf{\#define} 预处理器：\begin{itemize}
			\item 形式：\#define identifier value
			\item 示例：\#define LENGTH 3
		\end{itemize}
		\item 使用 \textbf{const} 关键字：\begin{itemize}
			\item 形式：const type variable = value ;
			\item 示例：const int LENGTH = 1 ;
		\end{itemize}
	\end{enumerate}
	\textbf{NOTE}：建议常量使用大写。
	\begin{framed}
		\textbf{\#define 与 const}：
		\begin{itemize}
			\item \textbf{\#define} 是宏定义，不能定义常量，不为宏名分配内存。
			\item \textbf{const} 不为常量分配内存，本质上是改变一个变量的存储类，将其所占的内存改为只读。
		\end{itemize}
		\textbf{转义序列(Escape Sequence)}：
		\begin{itemize}
			\item \textbackslash ooo 是表示为三位八进制数，如：‘\textbackslash 101’ = ‘0101’。
			\item \textbackslash xhh 中 x 固定，表示十六进制（hexadecimal），h也表示十六进制，如：‘\textbackslash x41’=‘\textbackslash 101’。
		\end{itemize}
		\textbf{define} 与 \textbf{const}的区别：
		\begin{enumerate}
			\item \textbf{编译器处理方式}：\begin{itemize}
				\item \textbf{\#define} 宏是在预处理阶段展开；
				\item \textbf{const} 常量是编译运行阶段使用。
			\end{itemize}
			\item \textbf{类型和安全检查不同}：\begin{itemize}
				\item \textbf{\#define} 宏没有类型，不做任何类型检查，仅仅展开。
				\item \textbf{const} 常量有具体的类型，在编译阶段执行类型检查。
			\end{itemize}
			\item \textbf{存储方式不同}：\begin{itemize}
				\item \textbf{\#define} 宏仅仅是展开，不分配内存。（宏定义不分配内存，变量定义分配内存。）
				\item \textbf{const} 变量会在内存中分配（栈或者堆）。
			\end{itemize}
			\item \textbf{const}可以节省空间，减少不必要的内存分配。其只给出对应的内存地址，\textbf{const}定义的常量在程序运行过程中只拷贝一份（为全局的只读变量，存在静态区），而\textbf{\#define}定义的常量在内存中有若干个拷贝。
			\item 编译器通常不为普通的\textbf{const}常量分配存储空间，而是保存在符号表中，使得其成为一个编译期间的常量，没有存储和读内存的操作，效率高。
			\item 宏替换只作替换，不计算，不进行表达式求解。
		\end{enumerate}
		\textbf{define 的“边缘效应”}：\textbf{define} 宏只做替换，不做计算，对于优先顺序不同计算结果不同的表达式，注意添加合适的括号保证优先级。

		\textbf{单引号和双引号的区别}：
		\begin{itemize}
			\item \textbf{单引号$''$}：内容是\textbf{char} 类型，为一个字符，对应ASCII表中的序列值。
			\item \textbf{双引号$""$}：字符串存到一个数组中，字符串代表指向这个数组起始字符的指针。
		\end{itemize}
	\end{framed} 

	\clearpage
	\section{C 存储类}
	存储类定义了C程序中变量/函数的范围（可见性）和生命周期，放置在它们所修饰的类型之前。
	\subsection{auto存储类}
	\textbf{auto存储类} 是所有局部变量默认的存储类。
	
	只能用在函数内，只能修饰局部变量。
	\subsection{register存储类}
	\begin{itemize}
		\item 定义存储在寄存器而不是RAM中的局部变量，\emph{有可能}存储在寄存器中。
		\item 最大尺寸等于寄存器的大小。
		\item 不能对其应用一元$'\&'$运算符。
		\item 用于需要快速访问的变量，如：计数器。
	\end{itemize}
	\subsection{static存储类}
	\begin{itemize}
		\item 指示编译器在程序生命周期内保持局部变量的存在，而不需要在每次进入和离开作用域时进行创建和销毁。
		\item 保持局部变量可以在函数调用之间保持局部变量的值。
		\item 也可用于全局变量，使得变量的作用域限制在声明它的文件内。
		\item 全局声明的\textbf{static}变量的作用域在声明它的文件内。
		\item 全局声明的\textbf{static}变量可以被任何函数或方法调用，只要出现在同一个文件中。
	\end{itemize}
	\subsection[]{extern存储类}
	\begin{itemize}
		\item 提供一个全局变量的引用，对于所有文件都是可用的。
		\item 对于未初始化的变量，会把变量名指向一个先前定义过的存储位置。
		\item \textbf{extern}用来在另一个文件中声明一个全局变量或函数。
		\item 相当于有多个文件共享系统给的全局变量或函数。
	\end{itemize}
	\begin{framed}\textbf{NOTES:}\\
			\textbf{C 语言中全局变量、局部变量、静态全局变量和静态局部变量的区别}
			\captionof{table}{不同变量作用域}
		\begin{tabular*}{\linewidth}{l|l|p{14em}}
			\toprule
			变量&作用域&描述\\
			\midrule
			\textbf{全局变量}&全局作用域&只在一个源文件出现，可作用于其他所有源文件，但是需要用\textbf{extern}进行声明\\
			\midrule
			\textbf{静态全局变量}&全局作用域&仅作用于定义的文件中，即\textbf{static}修饰的变量有文件作用域。不同文件相同名称的静态全局变量为不同不良\\
			\midrule
			\textbf{局部变量}&局部作用域&为自动对象（auto），只在函数执行期间存在，调用结束后撤销\\
			\midrule
			\textbf{静态局部变量}&局部作用域&初始化一次，从初始化到程序结束一直存在，只对于定义自己的函数体始终可见\\
			\bottomrule
		\end{tabular*}\\
		\textbf{变量的内存分配机制}：
		\begin{itemize}
			\item 全局变量，静态全局变量，静态局部变量都在静态存储区分配空间，局部变量在栈里分配空间。
			\item 局部变量改为静态变量是改变了它的存储方式（生存期）
			\item 全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。
			\item 使用全局变量，静态全局变量，静态局部变量，需要考虑重入问题，他们全局可见。
			\item 可重入的函数要避免在函数内使用staic变量。
			\item 必须使用static变量的情况：函数的返回值为指针类型，必须是static的局部变量的地址作为返回值，若为auto，则返回为错指针。
		\end{itemize}
		\textbf{register变量}：\begin{itemize}
			\item 动态或静态变量都是存在内存中，如果使用则由内存送到运算器中，需要存储则再送到内存中。
			\item 对于需要引用的局部变量，如循环体中，可将局部变量保存到CPU的寄存器中，称为寄存器变量，可用于提高效率。
			\item 只有局部自动变量和形参可用做寄存器变量。
		\end{itemize}
		\textbf{static的不同作用}
		\begin{itemize}
			\item \textbf{修饰局部变量}：\\变量放在静态数据区，生命周期持续到整个程序执行结束，作用域未变，只在初始运行时初始化一次，多次调用变量不再重新初始化，变量值得到保留，为上次调用所得结果。\\若未初始化，则整型自动赋0，字符数组赋'\textbackslash 0'。
			\item \textbf{修饰全局变量}\\ \textbf{static}对全局变量修饰后改变其作用域范围，只对本源文件可见。
			\item \textbf{修饰函数}：改变作用域。
		\end{itemize}
	\end{framed}

	\clearpage
	\section{C 运算符}
	包括：\textbf{算术运算符}，\textbf{关系运算符}，\textbf{逻辑运算符}，\textbf{位运算符}，\textbf{赋值运算符} 和 \textbf{杂项运算符}。
	\subsection{算术运算符}
	\captionof{table}{算术运算符}
	\begin{tabular*}{\linewidth}{c|l}
		\toprule
		运算符 & 描述\\
		\midrule
		+ & 把两个操作数相加\\
		- & 从第一个操作数中减去第二个操作数\\
		$*$ & 把两个操作数相乘\\
		/ & 分子除以分母\\
		\% & 取模运算符，整除后的余数\\
		++ & 自增运算符，整数值增加1\\
		\verb|--| & 自减运算符，整数值减少1\\
		\bottomrule 
	\end{tabular*}
	\textbf{Note}：\textbf{= ++ a (= $--$ a)} 是先运算，后赋值； \textbf{= a ++ (= a $--$)} 是先赋值，后运算。

	\subsection{关系运算符}
	\captionof{table}{关系运算符}
	\begin{tabular*}{\linewidth}{c|p{28em}}
		\toprule
		运算符&描述\\
		\midrule
		== & 检查两个操作数的值是否相等，若相等则条件为真。\\
		!= & 检查两个操作数的值是否相等，若不相等则条件为真。\\
		> & 检查左操作数的值是否大于右操作数的值，若是则条件为真。\\
		< & 检查左操作数的值是否小于右操作数，若是则条件为真。\\
		>= & 检查左操作数的值是否大于或等于右操作数的值，若是则条件为真。\\
		<= & 检查左操作数是否小于或等于右操作数，若是则条件为真。\\
		\bottomrule
	\end{tabular*}

	\subsection{逻辑运算符}
	\captionof{table}{逻辑运算符}
	\begin{tabular*}{\linewidth}{c|p{28em}}
		\toprule
		运算符 & 描述\\
		\midrule
		\&\& & 逻辑与运算符。两个操作数都非零时条件为真。\\
		$||$ & 逻辑或运算。若两个操作数中有一个非零，则条件为真。\\
		$!$ & 逻辑非运算符。用于逆转操作数的逻辑状态。若条件为真则逻辑非运算符将使其为假。\\
		\bottomrule
	\end{tabular*}

	\subsection{位运算符}
	\textbf{位运算符}：作用于位，逐位执行操作：
	\captionof{table}{位运算符真值表}
	\begin{center}
		\begin{tabular*}{0.35\linewidth}{c|c|c|c|c}
			\toprule
			p&q&p\&q&p$|$q&p\verb|^|q\\
			\midrule
			0&0&0&0&0\\
			0&1&0&1&1\\
			1&1&1&1&0\\
			1&0&0&1&1\\
			\bottomrule
		\end{tabular*}
	\end{center}
	\captionof{table}{位运算解释}
	\begin{tabular*}{\linewidth}{c|p{28em}}
		\toprule
		运算符& 描述\\
		\midrule
		\& & 按位与操作，按二进制位进行“与”运算\\
		$|$ & 按位或运算符，按二进制进行“或”运算\\
		\verb|^|& 异或运算符，按二进制进行“异或”运算\\
		~ & 取反运算符，按二进制进行“取反”运算\\
		$<<$ & 二进制左移运算符，将一个运算对象的个二进制位全部左移若干位（左侧的二进制丢弃，右侧补0）\\
		$>>$ & 二进制右移运算符，将一个数的各二进制位全部右移若干位，正数左侧补0，负数左侧补1，右侧丢弃。\\
		\bottomrule
	\end{tabular*}
	\subsection{赋值运算符}
	\captionof{table}{赋值运算符}
	\begin{tabular*}{\linewidth}{l|p{28em}}
		\toprule
		= & 简单的赋值运算符，把右边的操作数的值赋给左边的操作数。\\
		+= & 加且赋值运算符。把右边操作数加上左边操作数的结果赋给左边操作数\\
		-= & 减且赋值运算符。把左操作数减去右操作数的结果赋给左边操作数\\
		$*=$ & 乘且赋值运算符。把左边操作数乘以右边操作数的结果赋给左边操作数\\
		/= & 除且赋值运算符。把左边操作数处以右边操作数的结果赋值给左边操作数\\
		\%= & 求模且赋值运算符，求两个操作数的模赋值给左边操作数\\
		$<<=$ & 左移且赋值运算符\\
		$>>=$ & 右移且运算符\\
		\&= & 按位与且赋值运算符 \\
		\^= & 按位异或且赋值运算符\\
		|= & 按位或且赋值运算符\\ 
		\bottomrule
	\end{tabular*}
	\subsection{杂项运算符}
	\captionof{table}{杂项运算符}
	\begin{tabular*}{\linewidth}{l|l}
		\toprule
		运算符 & 描述 \\
		\midrule
		sizeof() & 返回变量的大小\\
		\& & 返回变量的地址\\
		$*$ & 指向一个变量\\
		?: & 条件表达式，若条件为真，则值为x：否则值为y。\\
		\bottomrule
	\end{tabular*}
	\subsection{C 中的运算符优先级}
	下表按照运算符优先级从高到底列出各个运算符，优先级高的会被优先计算。
	\captionof{table}{运算符及其对应的优先级}
	\begin{tabular*}{\linewidth}{l|l|l}
		\toprule
		类型 & 运算符 & 结合性\\
		\midrule
		后缀 & ()[]	-> . ++ -- & 从左到右\\
		一元 & + - ! ~ -- (type)* \& sizeof & 从右到左\\
		乘除 & $*$ / \% & 从左到右\\
		加减 & + - & 从左到右 \\
		移位 & << >> & 从左到右\\
		关系 & < <= > >= & 从左到右 \\
		相等 & == != & 从左到右 \\
		位与AND & \& & 从左到右 \\
		位异或XOR & \^ & 从左到右 \\
		位或OR & | & 从左到右 \\
		逻辑与AND & \&\& & 从左到右 \\
		逻辑OR & || & 从左到右 \\
		条件 & ?: & 从右到左\\
		赋值 & = += -= *= /= \%= > >= < <= \&= \^= |= & 从右到左\\
		逗号 & , & 从右到左\\
		\bottomrule
	\end{tabular*}
	\begin{framed}
		\textbf{NOTES:}\\
		\textbf{利用异或}\verb|^|\textbf{不引入其他变量来交换两个数的值}
		\begin{enumerate}
			\item a=a\verb|^|b;
			\item b=a\verb|^|b;
			\item a=a\verb|^|b;
		\end{enumerate}
		\textbf{利用位与\& 运算来判断一个整数是否为2的整数次幂}\\如果一个整数m是2的n次幂，则其二进制的最高位为1，其他位为0。而m-1的二进制形式中1的位置正好与其错开，所以两者位与为0。\\ \textbf{判断语句：} (m > 0) \& \& ((m \& (m - 1)) == 0);

		\textbf{取余运算\%：}\begin{itemize}
			\item 取余运算只针对整数，即两边必须都是整数。
			\item 余数可为正或为负，取决于\% 左侧的整数。
		\end{itemize}
		\textbf{不同长度的数据进行位运算}\\按照右端对齐，对于位数不足的数的左端进行补足。\begin{itemize}
			\item 整型数据为正数，左侧0补足；
			\item 整型数据为负数，左侧1补足；
			\item 整型数据为无符号数，左侧0补足。
		\end{itemize}
		\textbf{|和||，\& 和\& \& 的区别}
		\begin{itemize}
			\item \& \& :两个操作数都非零则条件为真。
			\item || ：两个操作数中任意一个非零，则条件为真。
			\item | ：按位或运算，\& ：按位与运算。
			\item \& 和\& \& : 都可在判断语句中实现“和”功能，但是区别是\& 要判断两侧，再给出结果，而\& \& 再判断左侧非真时就结束了，从而提高了运算的效率。
		\end{itemize}
	\end{framed}

	\clearpage
	\section{C 判断}
	\textbf{判断结构}：指定一个或多个要测试的条件，以及条件为真时要执行的语句（必选）和条件为假时要执行的语句（可选）。\\ \textbf{非零}和\textbf{非空}的值为 \textbf{true},\textbf{零}或\textbf{null}为\textbf{false}。
	\begin{figure}
		\centering
		\includegraphics[width=0.5\linewidth]{figures/if.png}
		\caption{判断结构}
	\end{figure}
	\subsection{判断语句}
		\captionof{table}{判断语句}
	\begin{tabular*}{\linewidth}{l|p{25em}}
		\toprule
		语句 & 描述 \\
		\midrule
		if 语句 & 一个if语句 由一个布尔表达式后跟一个或多个语句组成。\\
		if … else 语句 & 一个if 语句后跟一个可选的 else
		语句 ，else语句 在布尔表达式为假时执行。\\
		嵌套 if 语句 & 可在if 或else if 语句内使用另一个 if 或 else if 语句。\\
		switch 语句 & 一个switch 语句允许测试一个变量等于多个值的情况。\\
		\bottomrule
	\end{tabular*}
	\subsection{?:运算符(三元运算符)}
	\begin{framed}
		Exp1 ? Exp2 : Exp3;
	\end{framed}
	? 表达式的值是由Exp1 决定的。如果Exp1 为真，则计算Exp2 的值，结果即为整个？表达式的值。如果Exp1 为假，则计算Exp3 的值， 结果即为为整个 ？ 表达式的值。
	\begin{figure}
		\centering
		\includegraphics[width=0.5\linewidth]{figures/Conditional_Statement.png}
		\caption{条件运算符}
	\end{figure}
	\subsection{循环类型}
	\captionof{table}{循环类型}
	\begin{tabular*}{\linewidth}{l|p{23em}}
		\toprule
		循环类型 & 描述 \\
		\midrule
		while 循环 & 当条件为真时，重复语句或语句组。它会在循环主体之前测试条件。\\
		for 循环 & 多次执行一个语句序列，简化管理循环变量的代码。\\
		do……while 循环 & 除了它是循环主体结尾测试条件外，其他与while语句类似。\\
		嵌套循环 & 可在while，for 或 do……while 循环内使用一个或多个循环。\\
		\bottomrule
	\end{tabular*}

	\subsection{循环控制语句}
	改变代码执行顺序，实现代码的跳转。
	\captionof{table}{循环控制语句}
	\begin{tabular*}{\linewidth}{l|p{25em}}
		\toprule
		控制语句 & 描述 \\
		\midrule
		break 语句 & 终止 循环 或switch 语句，程序将继续执行紧接着循环或switch的下一条语句。\\
		continue 语句 & 告诉循环体立即停止本次循环迭代，重新开始下一次循环迭代。\\
		goto 语句 & 将控制转移到标记的语句。\textbf{不建议使用}\\
		\bottomrule
	\end{tabular*}
	\subsection{无限循环}
	如果条件为真，则循环将变成无限循环。for 循环可实现无限循环。由于构成循环的三个表达式中的任何一个都不是必须的，可将某些条件表达式留空来构成一个无限循环。
	\begin{framed}
		for( ; ; )
	\end{framed}
	当表达式的不存在时，被假设为真。\\按 \textbf{ctrl + c}终止一个无限循环。

	\clearpage
	\section{C 函数}
	\begin{itemize}
		\item 函数是一组一起执行一个任务的语句。每个C 程序至少有一个函数，即主函数\textbf{main()}。
		\item \textbf{函数声明}告诉编译器 函数的\textit{名称，返回类型}和\textit{参数}。
		\item \textbf{函数定义}提供了函数的实际主体。
	\end{itemize}
	\subsection{定义函数}
	一般形式为：
	\begin{lstlisting}[language=C]
		return_type function_name( parameter list)
		{
			body of the function
		}
	\end{lstlisting}
	在 C 语言中，函数是由一个函数头和一个函数主体组成，其所有组成部分：
	\begin{itemize}
		\item \textbf{返回类型}：一个函数可以返回一个值。return\_type 是函数返回值的数据类型。有些函数执行所需发操作而不返回值，return\_type 是关键字 void。
		\item \textbf{函数名称}：为函数的实际名称。函数名和参数列表一起构成函数签名。
		\item \textbf{参数}：参数就像占位符。当函数被调用时，向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的\textit{类型，顺序，数量}。参数时可选的，函数可能不含参数。
		\item \textbf{函数主体}：包括一组定义函数执行任务的语句。
	\end{itemize}
	\subsection{调用函数}
	调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的函数，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序的控制权交还给主程序。\\调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。
	\subsection{函数参数}
	\begin{itemize}
		\item 如果函数要使用参数，则必须声明接受参数值的变量。这些变量成为函数的\textbf{形式参数}。
		\item 形式参数想函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。
	\end{itemize}
	\captionof{table}{两种向函数传递参数的方式：}
	\begin{tabular*}{\linewidth}{l|p{27em}}
		\toprule
		调用类型 & 描述 \\
		\midrule
		\textbf{传值调用} & 将参数的实际值复制给函数的形式参数。修改函数内的形式参数不会影响实际参数。\\
		\textbf{引入调用} & 通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行操作。\\
		\bottomrule
	\end{tabular*}
	\begin{framed}
		\textbf{NOTES:}\begin{itemize}
			\item \textbf{内部函数和外部函数：}\begin{enumerate}
				\item \textbf{内部函数：}一个函数只能被本文件中其他函数所调用，不同文件中有同名的内部函数，互不干扰。在函数名和函数类型前面加\textbf{static}。\begin{framed}
					static 类型名 函数名 (形参表)
				\end{framed}
				\item \textbf{外部函数：}定义函数时，在函数的首部的最左端加关键字\textbf{extern}，可供其他文件调用。\\C 规定，定义函数时省略extern，则默认为外部函数。\\在需要调用此函数的其他文件中，需要对此函数做声明。声明时，要加关键字extern，表示该函数是在其他文件中定义的外部函数。
			\end{enumerate}
			\item \textbf{内联函数：}\\为用inline关键字修饰的函数。在类内定义的函数被默认成内联函数。\\内联扩展是用来\textbf{消除函数调用时的时间开销}。通常用于频繁执行的函数，对于小内存空间的函数非常收益。\\ \textbf{注意：}\begin{itemize}
				\item 调用函数不能定义为内联函数。
				\item 内联函数一般适合于不存在while和switch等复杂结构且只有1--5条语句的小函数，否则编译系统将是为普通函数。
				\item 内联函数只能先定义后使用，否则被认为时普通函数。
				\item 对内联函数不能进行异常的接口声明。
			\end{itemize}
			\item \textbf{关于main函数的参数}\\代码：int main(int argc, char *argv[])\\argc 和argv 是main函数的形式参数，由系统规定。\\可以在命令行下带参数执行，命令行执行的形式为：可执行文件名称 参数1 参数2 ...... 参数n\\利用这种方法，命令行字符串将视为实际参数传给main函数：\begin{itemize}
				\item 可执行文件名称和所有参数的个数之和传递给argc。
				\item 可执行文件名称（包括路径名称）作为一个字符串，首地址被赋给argv[0]，参数1也作一个字符串，手地址被赋给argv[1]......。
			\end{itemize}
			\item \textbf{函数参数传递常用的三种方式：}\begin{enumerate}
				\item \textbf{值传递：}单向传递，传递过程中只是改变了形参的数值，未改变实参的数值。
				\item \textbf{指针传递（$*$a）：}通过地址传递改变实参的值。
				\item \textbf{引用传递（\&a）：}形参引用实参，参加运算的为实参本身。
			\end{enumerate}
			\item 函数声明和函数原型的参数名可以不同，只要知道函数参数的类型。
			\item \textbf{格式占位符（\%）：}\captionof{table}{格式占位符：}\begin{tabular*}{\linewidth}{l|l}
				\toprule
				\%d \%i & 整数\\
				\%f & 浮点 \\
				\%s & 字符型 \\
				\%c & char \\
				\%p & 指针 \\
				\%fL & 长log \\
				\%e & 科学计数 \\
				\%g & 小数或科学计数\\
				\%a,\%A & 读入一个浮点数（C99）\\
				\%c & 读入一个字符 \\
				\%d & 读入十进制整数 \\
				\%i & 读入十进制，八进制，十六进制整数\\
				\%o & 读入八进制整数\\
				\%x, \%X & 读入十六进制数 \\
				\%s & 读入一个字符串，遇到空格，制表符或换行符结束。\\
				\%f,\%F,\%E,\%g,\%G & 用于输入实数，可以用小数形式或指数形式输入。\\
				\%p & 读入一个指针 \\
				\%u & 读入一个无符号十进制整数\\
				\%n & 至此已读入值的等价字符数\\
				\%[] & 扫描字符集合 \\
				\%\% & 读\% 符号\\
				\bottomrule
			\end{tabular*}
			\item 函数的调用：先声明，后调用。函数可以在main()函数之后，但是声明必须在main() 函数之前。或者定义就在main()函数之前。
		\end{itemize}
	\end{framed}

	\clearpage
	\section{C 作用域规则}
	作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问到。C中有三个地方可以声明变量：\begin{itemize}
		\item 在函数或块内部的\textbf{局部变量}
		\item 在所有函数外部的\textbf{全局变量}
		\item 在\textbf{形式参数}的函数参数定义中
	\end{itemize}
	\subsection{局部变量}
	只能被该函数或该代码块内部的语句使用，如在main()函数内部或其他自定义函数内部。
	\subsection{全局变量}
	定义在函数外部，通常在程序的顶端。全局变量在整个程序生命周期内都是有效的，任意函数内部能访问全局变量。
	\begin{framed}
		NOTES:局部变量和全局变量的名称可以相同，但是在函数内，如果名字相同，会使用局部变量。
	\end{framed}
	\subsection{形式参数}
	函数的参数，形式参数，被当成该函数内的局部变量，如果与全局变量同名，会被优先使用。
	\begin{framed}
		\textbf{全局变量与局部变量的区别：}
		\begin{itemize}
			\item 全局变量保存在内存的全局存储区中，占用静态的存储单元。
			\item 局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。
		\end{itemize}
	\end{framed}
	\subsection{初始化局部变量和全局变量}
	定义局部变量时，相同不会对其进行初始化，需要自行初始化。\\定义全局变量时，系统会自动对其进行初始化。\begin{center}
		\captionof{table}{全局变量初始化}
	\begin{tabular*}{0.4\linewidth}{l|l}
		\toprule
		数据类型 & 初始化默认值\\
		\midrule
		int & 0 \\
		char & '\textbackslash 0'\\
		float & 0 \\
		double & 0 \\
		pointer & NULL \\
		\bottomrule
	\end{tabular*}
	\end{center}

	\clearpage
	\section{C 数组}
	\textbf{数组}：存储一个固定大小的相同类型元素的顺序集合。被认为是一系列相同类型的变量。\\
	所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。
	\subsection{声明数组}
	声明一个数组，需要指定元素的类型和元素的数量，如下：\begin{framed}
		\textbf{type arrayName [ arraySize ]}\\
		\textbf{arraySize}必须是一个大于零的整数常量\\
		\textbf{type}可以是任意有效的C数据类型。
	\end{framed}
	\subsection{初始化数组}
	可使用一个初始化语句，如：double b[2]=\{1, 2\};\\
	\{ \} 之间的值的数量不能大于数组声明中[]中指定的元素数目。\\
	若忽略数组的大小，数组的大小则为初始化时元素的个数。\\
	所有数组都是以0作为第一个元素的索引，也称之为基索引。所以数组array第\emph{i}个元素为：array[i-1]。
	\subsection{多维数组}
	一般形式：\begin{framed}
		type name[size1][size2]...[sizeN];
	\end{framed}
	\subsubsection{二维数组}
	本质上是一个一维数组的列表。
	\begin{framed}
		type arrayName [x][y];
	\end{framed}
	表示一个x行y列的列表。
	\begin{framed}
		\begin{itemize}
			\item 二维数组在逻辑上是方阵，由行和列组成。\\在物理上是线性的，按行依次进行存放，内存是连续的。\\二维数组名的步长是一行的长度。
			\item 二维数组作为参数时，必须指明所有维数大小或省略第一维，不能省略第二维或者更高维的大小。编译器的处理数组的方式:\begin{framed}
			设数组 int a[m][n],如果要访问a[i][j]的值，寻址方式为：\\ \&a[i][j]= \&a[0][0]+i$*$sizeof(int)*n+j$*$sizeof(int);\\因此可以省略第一维的维数，但不能省略第二维的位数。\\定义二维数组时，可以省略第一维，编译器根据初始化语句自动确定第一维度。
			\end{framed}
		\end{itemize}
	\end{framed}
	\subsection{C 传递数组给函数}
		\begin{enumerate}
			\item 形式参数是一个指针：\textbf{void myFunction(int $*$param)}
			\item 形式参数是一个已定义大小的数组：\textbf{void myFunction(int param[sizeofarray])}
			\item 形式参数是一个未定义大小的数组：\textbf{void myFunction(int param[])}
		\end{enumerate}
		\begin{framed}
			\textbf{NOTES:}\\
			\textbf{二维数组传递给函数}
			\begin{itemize}
				\item 第一维的长度可以不指定，但第二维的长度必须指定。\\ \emph{void function(int array[ ][colofarray], ...)}
				\item 指向一个有\emph{n} 个元素的以为数组的指针。\\ \emph{void function(int $*$array)[n], int i, int j}
				\item 利用数组是顺序存储的特性，通过降维来访问原数组。\emph{void function(int $*$array, int i, int j)}
			\end{itemize}
		\end{framed}
		\subsection{从函数返回数组}
		C 语言不允许返回一个完整的数组作为函数的参数。\\
		可以通过指定不带索引的数组名来返回一个指向数组的指针。\\
		不支持在函数外返回局部变量的地址，除非定义局部变量为static变量。
		\begin{framed}
			\textbf{NOTES:}\\
			\textbf{srand((unsigned)time(NULL))}
			\begin{itemize}
				\item 是拿当前系统时间作为种子，由于时间是变化的，种子也是变化的，所以可以产生不同的随机数。
				\item 使用时，参数可以是unsigned型的任意数据。
				\item 如果不使用srand，而直接使用\textbf{rand( )}产生的随机数，多次运行的结果是一样的。
			\end{itemize}
		\end{framed}
		\subsection{C 指向数组的指针}
			数组名是一个指向数组中第一个元素的常量指针。
			\begin{framed}
				\textbf{double array[ sizeofarray ]}\\
				\textbf{array}是一个指向\&array[0]的指针，即数组array的第一个元素的地址。\\
				\textbf{$*$p=array} 是将$*$p赋值为array的第一个元素的地址\\
				可用数组名或将其赋值给一个指针，利用指针对数组中各元素进行访问。\\
				\begin{framed}
					double $*$p;\\
					double array[sizeofarray];\\
					p = array;\\
					可用 $*$p，$*$(p+1)，...，访问数组array的第一，二，...个元素\\
					或者直接利用$*$array，$*$(array+1)，...来访问数组中的第一，二，...个元素。
				\end{framed}
			\end{framed}
			\begin{framed}
				\textbf{NOTES}:
				\begin{itemize}
					\item 可利用\textbf{sizeof(array)/sizeof(array[0])}来确定数组单元个数。
					\item 数组array中：\textbf{array[0],array[1]...}代表的是数组的第一，二，...个值。而\textbf{array,(array+1),(array+2),...}代表的是数组的第一，二...个元素的地址。其中\textbf{a}代表了整个数组的首地址。
					\item 数组的初始化：\begin{enumerate}
						\item 可以只给部分元素赋值，当{ }中值的个数少于元素的个数，只给前面的部分元素赋值，剩下的元素自动初始化为0。
						\item 可以通过\textbf{\{0\}}将数组中的所有元素初始化为0。
					\end{enumerate}
					\item \textbf{指针和数组的区别}：\begin{enumerate}
						\item 指针：也是一个变量，存储的数据是地址。
						\item 数组名：代表的是该数组最开始的一个元素的地址。
						\item 对数组元素的a[i] 的引用也可以写成$*$(a+i)这种形式。
						\item 赋值语句\textbf{p=\&a[0]}也可以写成\textbf{p=a}。
						\item p是一个指针，\textbf{p[i]} 和 \textbf{$*$(p+i)}等价。
						\item \textbf{NOTES:}指针是一个变量，可以进行数值运算，数组名不是变量，不能进行数值运算。
					\end{enumerate}
					\item \textbf{指针与数组名的关系}：\begin{itemize}
						\item 函数的参数中 数组类型的参数int a[ ] 本质上是指针，也可以直接换成int $*$a；
						\item 可以用数组的运算符[] 进行运算，而且可以通过a[0]就直接修改了外面的数组元素。
						\item size of (a)=sizeof(int $*$)所以函数内部不能得到数组的长度，只能传一个len进去。
						\item 数组变量是特殊的指针，数组变量本身表达地址。
						\item 数组变量无需取地址符\&。
						\item 数组的元素表达的是变量，需要用\& 取地址符，如：\&a[1]。
						\item []运算符可以对数组做，也可以对指针做。
						\item $*$运算符可以对指针做，也可以对数组做。
						\item 数组是const的指针，所以不能被赋值，如：int a[]实质上等价于int const $*$a, a是一个常数，不能被改变。
					\end{itemize}
					\item \textbf{数组赋值的区别}：\\char a[]="abc"后面会自动加上'\textbackslash0'。\\char a[]={'a','b','c'}后面不会加上'\textbackslash0'。\\所以上一个比下一个长度长。
				\end{itemize}
			\end{framed}

			\clearpage
			\section{C enum (枚举)}
			枚举的语法定义格式：\begin{framed}
				enum 枚举名 {枚举元素1，枚举元素2，...}
			\end{framed}
			\textbf{NOTES:}\begin{itemize}
				\item 第一个枚举成员在没有指定值时默认为整型0，后续未指定的枚举成员在前一个成员上加上1。
			\end{itemize}
			\subsection{枚举变量的定义}
			\begin{enumerate}
				\item 先定义枚举类型，再定义枚举变量。\begin{framed}
					\textbf{enum} enumName\{ enumEle1,...\};\\
					\textbf{enum} enumName eunmVar;
				\end{framed}
				\item 定义枚举类型的同时定义枚举变量。\begin{framed}
					\textbf{enum} enumName\{ enumEle1,...\}enumVar;
				\end{framed}
				\item 省略枚举名称，直接定义枚举变量。\begin{framed}
					\textbf{enum} \{ enumEle1,...\} enumVar;
				\end{framed}
			\end{enumerate}
			枚举类型被当作int 或unsigned int类型来处理的，所以是没有办法遍历枚举类型的，但是当枚举类型是连续是可以实现有条件的遍历。若枚举类型不连续，这种枚举是无法遍历的。

			\clearpage
			\section{C 指针}
			每个变量都有一个内存位置，每个内存位置都定义了可使用连字号（\&）运算符访问的地址，他表示在内存中的一个地址。
			\subsection{什么是指针？}
			\textbf{指针}：是一个变量，其值为另一个变量的地址，即内存位置的直接地址。需要在利用指针存储其他变量的地址之前，先对其进行声明，声明一般为：\begin{framed}
				type $*$var-name;
			\end{framed}
			\textbf{type}是指针的基类型，为C中的一个有效数据类型，\textbf{var-name}是指针变量的名称。\\实际数据类型，对应指针的值的类型都是一样的，都是代表内存地址的长的十六进制数。\\唯一的区别是，指针所指向的变量或常量的数据类型不同。
			\subsection{如何使用指针？}
			会进行如下操作：定义一个指针变量，把变量地址赋值给指针，访问指针变量中可用地址的值。
			\subsection{C 中NULL指针}
			在变量声明的时候，如果没有明确的地址可以赋值，为指针变量赋一个NULL值，称其为空指针。\\
			可利用if 语句检查一个空指针：\begin{framed}
				if(p) /$*$如果p非空，则完成...
			\end{framed}
			\subsection{指针的算术运算}
			指针是用数值表示的地址，可以对指针执行算术运算：++，--，+，-。\\
			根据定义指针时其类型，++为下个位置，如：如果指针为整型，++后为当前地址加4；如果是字符类型时，为当前位置加1
			\subsubsection{递增一个指针（p++）}
			变量指针可以递增，数组不可以递增，数组可以看成一个变量常量。
			\subsubsection{递减一个指针}
			同样的，即把值减去其数据类型的字节数。
			\subsubsection{指针的比较}
			指针可以用关系运算符进行比较，如：==，<，>...
			\subsection{指针数组}
			让数组存储指向int或char或者其他类型的指针。\begin{framed}
				int $*$p[sizeofarray]\\
				把p声明为一个数组，有sizeofarray个整数指针组成。p中的每个元素，都是一个指向int值的指针。
			\end{framed}
			\begin{framed}
				\textbf{指针数组和数组指针的区别}\\ \textbf{NOTES:}
				\begin{itemize}
					\item 指针数组：变量是一个数组，其中所有元素都是指针类型。
					\item 数组指针：变量是一个指针，这个指针存放着的一个数组的首地址。
				\end{itemize}
			\end{framed}
			\subsection{C 指向指针的指针}
			指向指针的指针是一个多级间接寻址的形式，或者说是一个指针链。一个指针包含一个变量的地址。定义一个指向指针的指针时，第一个指针包括第二个指针的地址，第二个指针包括实际值的位置。
			\begin{figure}
				\centering
				\includegraphics[width=4in]{figures/pointer_to_pointer.jpg}
				\caption{指向指针的指针}
			\end{figure}
			\begin{framed}
				\textbf{声明：}在变量名前放置两个星号，如：\\
				int $**$var
			\end{framed}
			指向指针的指针的定义方法如下：
				\begin{lstlisting}[language=C]
					\\定义指针和指向指针的指针

					int var;
					int *ptr;
					int **pptr;

					\\获取变量和指针的地址

					ptr = &var;
					pptr = &ptr;
					
					\\使用指针
					
					*ptr
					*pptr

				\end{lstlisting}
			\subsection{C 传递指针给函数}
			C 允许传递指针给函数，只需声明函数参数类型为指针类型。
			\subsection{C 从函数返回指针}
			C 允许从函数返回指针，必须声明一个返回指针的函数。
			\begin{lstlisting}{language=C}
				int *myFunction()
				{
					...
				}
			\end{lstlisting}
			C语言不支持在调用函数时返回局部变量的地址，除非定义局部变量为static变量。因为局部变量时存储在内存的栈内，函数调用结束后，局部变量所占用的内存地址便被释放，因此当其他函数执行完成时，函数内的变量不再拥有那个内存地址，所以不能返回其指针。\\
			当定义变量为static变量时，变量的值放在内存中的静态数据区，不会随着函数执行结束而被清除。
			\begin{framed}
				\textbf{NOTES:}\begin{enumerate}
					\item \textbf{指针的一些复杂说明}\\\begin{tabular*}{\linewidth}{l|p{19em}}
						\toprule
						指针&说明\\
						\midrule
						int p;&一个普通的整型变量。\\
						int $*$p;&一个返回整型数据的指针。\\
						int p[n];&一个由整型数据组成的数组。\\
						int $*$p[n];&一个返回整型数据的指针所组成的数组。\\
						int ($*$p)[n];&一个指向整型数据组成的数组的指针。\\
						int $**$p;&一个指针，指向另一个指针，这个指针所指向的元素是整型数据。\\
						int p( int )&一个函数，其返回值为一个整型数据。\\
						int ($*$p)( int )&一个指向有一个整型参数且返回类型为整型的函数的指针。\\
						int $*$($*$p( int ))[ n ]& 一个参数为一个整型数据且返回一个指向由整型指针变量组成的数组的指针变量的函数。\\
						\bottomrule
					\end{tabular*}
					\item \textbf{指向函数的指针}\\先定义一个函数，然后定义一个相同输入输出类型的指针，将指针指向函数的基地址，即为函数指针。
					\item \textbf{数组指针} \\定义好的数组中赋值时，指针可以通过调整地址给数组赋值。\begin{framed}
						int* array = (int*)malloc(sizeof(int)$*$3);\\
						array+0 = 1;\\
						array+1 = 2;\\
						...
					\end{framed}
				\end{enumerate}
			\end{framed}

			\clearpage
			\section{函数指针}
			\textbf{函数指针：}指向函数的指针变量。\\
			\textbf{声明：}\begin{framed}
				typedef int ($*$fun\_ptr)(int, int);
			\end{framed}
			\textbf{NOTE:} 声明一个指向函数的指针，指针名为fun\_ptr，所指向的函数的输入为两个int型的变量，输出为typedef型(任何合法类型)\\
			\textbf{使用:} 
			\begin{framed}
				RetVal = fun\_ptr( int var1, int var2)
			\end{framed}
			\subsection{回调函数}
			\textbf{函数指针作为某个函数的参数}\\
			函数指针变量可以作为某个函数的参数来使用，回调函数就是通过函数指针调用的函数。\\
			\textbf{声明：}\begin{framed}
				typedef funNam ( int $*$array )
			\end{framed}
			\begin{framed}
				\textbf{NOTES:}
				\begin{enumerate}
					\item \textbf{size\_t}:是一种数据类型，近似无符号整型，容量范围一般大于int和unsigned。
					\item \textbf{size\_t}:在不涉及负值范围的表示size取值可使用size\_t。在\emph{stddef.h}（\emph{stdlib.h}?）头文件定义。
				\end{enumerate}
			\end{framed}

			\clearpage
			\section{C 字符串}
			字符串实际上是使用\textbf{null}字符'\textbackslash0'终止的一维字符数组。\\
			C 编译器会在初始化数组时，自动把'\textbackslash0'把在字符串的末尾。
			\begin{table}
				\caption{操作字符串的函数}
				\begin{tabular*}{\linewidth}{l|p{25em}}
					\toprule
					函数 & 功能\\
					\midrule
					strcpy(s1, s2)&复制字符串s2到字符串s1\\
					strcat(s1, s2)&连接字符串s2到字符串s1的末尾\\
					strlen(s1)&返回字符串s1的长度\\
					strcmp(s1, s2)&如果s1和s2是相同的，则返回0；如果s1<s2，则返回小于0；如果s1>s2，则返回大于0。\\
					strchr(s1, ch)&返回一个指针，指向字符串s1中字符ch的第一次出现的位置。\\
					strstr(s1, s2)&返回一个指针，指向字符串s1中字符串s2第一次出现的位置。\\
					\bottomrule
				\end{tabular*}
			\end{table}
			\begin{framed}
				\begin{enumerate}
					\item 字符串在进行单字符初始化时需要自行添加\textbf{\textbackslash 0}，否则会出现错误。\begin{framed}
						char str[n] = {'a', 'b',..., '\textbackslash 0'};
					\end{framed}
					而使用不定长数组初始化字符串时默认结尾为\textbackslash 0。\begin{framed}
						char str[] = "abc...";
					\end{framed}
					\item \textbf{strlen和sizeof的区别}：stren是函数，sizeof是运算操作符。sizeof计算的是变量的大小，不受字符\textbackslash 0影响。而strlen计算的是字符串的长度，以\textbackslash 0作为长度判断依据。
					\item 字符指针（注：指针不能直接赋给数组）\begin{framed}
						char *p = "abc...";
					\end{framed}
				\end{enumerate}
			\end{framed}

			\clearpage
			\section{C 结构体}
			C 数组允许定义可存储相同类型数据项的变量。\\ \textbf{结构}是C编程中一种用户自定义的可用发数据类型，允许存储不同类型的数据项。
			\subsection{定义结构}
			\textbf{struct}语句定义一个包括多个成员的数据类型。
			\begin{framed}
				struct \textbf{tag} \\
				\{\\
					member-list1\\
					member-list2\\
					member-list3\\
					...\\
				\} \emph{variable-list} ;\\
				\textbf{tag} 是结构体发标签\\
				member-list 是标准的变量定义\\
				\emph{variable-list} 结构变量，定义在结构的末尾，可指定一个或多个结构变量。
			\end{framed}

			\textbf{NOTES:}一般情况下，上述三个部分至少出现其中的两个。\\结构体的成员可以包括其他结构体，也可以包括指向自己结构体类型的指针。\begin{framed}
				\textbf{结构体中包括其他结构体：}\begin{framed}
						struct COMPLEX\\
						{\\
							...\\
							struct SIMPLE a;\\
						}
					\end{framed}
					\textbf{结构体中包括指向自己类型的指针}\begin{framed}
						struct NODE\\
						{\\
							...\\
							struct NODE $*$nextnode;\\
						}
					\end{framed}
					\textbf{两个结构体相互包含，需要对其中一个结构体进行不完整说明}\begin{framed}
						 struct B;\\

						 struct A\\
						 \{\\
							 struct B $*$p1;
							 ...\\
						 \}\\
						 struct B\\
						 \{\\
							struct A $*$p2;\\
						 \}
					\end{framed}
			\end{framed}
			\subsection{结构体变量的初始化}
			对结构体变量可以在定义试指定初始值。
			\begin{framed}
				struct STR\\
				\{\\
					...\\
				\} str = \{ ... \} ;\\

			\end{framed}

			\subsection{访问结构成员}
			使用成员访问运算符(.)，是结构变量名称和要访问的结构成员之间的一个句号。

			\subsection{结构作为函数参数}
			将结构作为函数参数，传参方式与变量和指针类似。

			\subsection{指向结构的指针}
			\textbf{定义指向结构的指针}：\begin{framed}
				struct strTag $*$struct\_pointer;
			\end{framed}
			\textbf{指针变量存储结构变量的地址}：
			\begin{framed}
				struct\_pointer = \& StrName;
			\end{framed}
			\textbf{利用->来指向结构体中的成员}
			\begin{framed}
				struct\_pointer -> member.title;
			\end{framed}

			\subsection{位域}
			对于某些信息不需要一个完整的字节，可利用“位域”或“位段”来节省空间。\\
			\textbf{位域}：把一个字节中的二进制划分成几个不同的区域，并说明每个区域的位数。每个区域都有一个域名，允许在程序中按域名进行操作。
			\subsection{位域的定义和位域变量的说明}
			\textbf{定义}
			\begin{framed}
				struct 位域结构名\\
				\{\\
					位域列表;\\
				\}\\
			\end{framed}
			位域列表的形式：\begin{framed}
				类型说明符 位域名: 位域长度
			\end{framed}
			\textbf{几点说明：}
			\begin{itemize}
				\item 一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一个位域时，则会从下一个单元起存放该位域。
				\item 由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，即不能超过8位二进位。
				\item 位域可以是无名位域，这时只用来填充或调整位置。无名位域不能使用。
			\end{itemize}
			\textbf{位域的使用}
			\begin{framed}
				位域变量名.位域名\\
				位域变量名->位域名
			\end{framed}
			\begin{framed}
				\textbf{NOTES:}
				\begin{itemize}
					\item 结构体中成员变量分配的空间是按照成员变量中占用空间最大的来作为分配单位，同样成员变量的存储空间也是不能跨分配单元的，如果当前空间不足，则会存储到下一个分配空间。
					\item \textbf{结构体数组}：\begin{itemize}
						\item 一个结构体变量可以存放一组数据，其每个数组元素都是一个结构体类型的数据。
						\item 定义结构体数组:\begin{framed}
							struct StrTag\\
							\{\\
								int num;\\
								...\\
							\} StrName[n];\\
						\end{framed}
						\item 结构体数组的初始化：\begin{framed}
							struct StrTag\\
							\{\\
								int Var;\\
								...\\
							\} StrNam[n]=\{ \{...\},\{...\},...\}
						\end{framed}先声明结构体类型，然后定义数组为该结构体类型，在定义数组时初始化。
						\item \textbf{结构体内存大小对齐原则}\begin{itemize}
							\item 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；
							\item 结构体每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如需要，编译器会在成员之间加上填充字节（internal adding）。即结构体成员的末地址减去结构体首地址（第一个结构体成员的首地址）得到的偏移量都要是对应成员大小的整数倍。
							\item 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如需要，编译器会在成员末尾加上填充字节。
						\end{itemize}
					\end{itemize}
				\end{itemize}
			\end{framed}

			\clearpage
			\section{C 共用体}
			\textbf{共用体}：一种特殊的数据结构，允许在相同的内存位置存储不同的数据类型。\\可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。\\共用体提供了一种相同的内存位置的有效方式。

			\subsection{定义共用体}
			使用\textbf{union}语句，与定义结构体类似。
			\begin{framed}
				union [ union tag]\\
				\{\\
				member1 definition;\\
				member2 definition;\\
				...\\
				\}[one or more union variables];\\
			\end{framed}
			共用体占用的内存应该足够存储共用体中最大的成员；
			\subsection{访问共用体成员}
			使用成员访问运算符(\textbf{.})，成员访问运算符是共用体变量名称和我们要访问的共用体成员之间的一个句号。

			\textbf{NOTES:}同一时间只能使用一个成员，若同时对于共用体中多个成员进行定义，则最后定义的成员有效，其他成员的定义会被覆盖。
			\begin{framed}
				\textbf{NOTES:}
				\begin{itemize}
					\item \textbf{结构体与共用体}：\begin{itemize}
						\item 结构体变量所占内存长度是其中最大字段大小的整数倍。
						\item 共用体变量所占的内存长度等于最长的成员变量的长度。
					\end{itemize}
					\item \textbf{作用：}节省内存，对于不会同时使用的多个数据类型，使用共用体，只占用最长的数据结构的内存空间。\\ \textbf{应用场景：}通信中的数据包。定义几种格式的包，收到包只够根据包的格式取出数据。
					\item \textbf{几个概念：}\begin{itemize}
						\item \textbf{位}：最小数据单位，只能是“0”或“1”。
						\item \textbf{字节}：8个位构成1个“字节（Byte）”，为存储空间的基本单位。一个字节存储1个字母或半个汉字。
						\item \textbf{字}：若干字节构成，位数成为字长。16位机一个\textbf{字}由2个字节构成。
						\item 64位机一个基本单位是8字节。对于\textbf{结构体，共用体，体域}中，按顺序分配内存，下一个字段所占大小若超过上一个字段的内存单元剩余部分，则将重新申请下一个内存单元，而上一个多出的部分将置空。 
					\end{itemize}
				\end{itemize}
			\end{framed}
			
			\clearpage
			\section{C 位域}
			对于数据类型不符合变量所需的长度，可以在声明中定义变量的长度来节省内存。\begin{framed}
				struct \\
				\{\\
					unsigned int a:n;// 定义a为1个字节长的变量 \\ 
				\}\\
			\end{framed}
			
			\subsection{位域声明}
			\textbf{形式}：\begin{framed}
				struct\\
				\{\\
					type [member\_name] : width;\\
				\}\\
			\end{framed}
			带有预定义宽度的变量被称为\textbf{位域}。位域可以存储多于1位的数。定义后不能使用超过定义的长度。\\\textbf{NOTES:}\emph{当要存的数值超过指定变量的预设定的长度，则超过的高位（二进制形式）会被抛弃}。

			\begin{framed}
				\textbf{NOTES:}
				\begin{itemize}
					\item \textbf{结构体内存分配原则}\begin{enumerate}
						\item 结构体中元素按照定义顺序存放在内存中，但并不是紧密排列。从结构体存储的首地址开始，每个元素存入内存中时，它都会认为内存是以自己的宽度来划分空间的，因此元素存放的位置一定会在自己大小的整数倍上开始。
						\item 检查计算出的存储单元是否为所有元素中最宽的元素长度的整数倍。若是，则结束；否则，将其补齐为整数倍。
						\item 定义位域时，各个成员的类型最好保持一致，不要混合使用，从而节省内存。
					\end{enumerate}
				\end{itemize}
			\end{framed}

			\clearpage
			\section{C typedef}
			\textbf{typedef} 为类型取一个新的名字。
			\begin{framed}
				typedef unsigned int BYTE;
			\end{framed}
			也可以来为自定义的数据类型取一个新的名字。
			\begin{framed}
				typedef struct StrTag\\
				\{\\
					...\\
				\} StrNam;\\
				
				定义：\\
				StrNam variable;
			\end{framed}
			\subsection{typedef VS \#define}
			\begin{itemize}
				\item \textbf{typedef} 仅限于为类型定义符号名称，\textbf{\#define} 不仅可以为类型定义别名，也能为数值定义别名。
				\item \textbf{typedef}是由编译器执行解释的，\textbf{\#define}是由预编译器进行处理的。
			\end{itemize}
			\begin{framed}
				\begin{itemize}
					\item \textbf{typedef 与 \#define的区别}\begin{enumerate}
						\item \#define 可以使用其它类型说明符对宏类型名进行扩展，但对于typedef所定义的类型名却不能。
						\item 在连续定义多个变量的时候，typedef能够保证定义的所有变量均为同一个类型，而\#define却无法保证。
					\end{enumerate}
					\item \textbf{typedef 与 \#define 比较}\\ \#define 只是字面上的替换，由预处理器执行，\#define A B 相当于替换功能，将所有B 替换成 A。\\typedef 具有三个特点：\begin{itemize}
						\item typedef 给出的符号名称仅限于类型，而不是对值。
						\item typedef的解释由编译器，而不是预处理器执行，不是简单的文本替换。
						\item typedef在受限范围内比\#define 灵活。 
					\end{itemize}
					\item typedef:为复杂的声明定义一个新的简单别名。
				\end{itemize}
			\end{framed}

			\clearpage
			\section{C 输入\& 输出}
			\subsection{标准文件}
			C 将所有设备都当成文件。所有设备被处理的方式与文件相同。\\C 中的I/O 通常使用 \emph{printf()} 和 \emph{scanf()}。\\ \emph{scanf()}用于从标准输入读取并格式化，\emph{printf()}发送格式化输出到标准输出。
			\begin{table}
				\centering
				\caption{标准文件}
				\begin{tabular}[]{l|l|l}
					\toprule
					标准文件&文件指针&设备\\
					\midrule
					标准输入&stdin&键盘\\
					标准输出&stdout&屏幕\\
					标准错误&stderr&屏幕\\
					\bottomrule
				\end{tabular}
			\end{table}
			\subsection{getchar() \& putchar()函数}
			\begin{itemize}
				\item \textbf{int getchar(void)}: 从输入读取下一个可用的字符，并把返回为一个整数。这个函数同一时间只会读取一个单一的字符，可循环从而读取多个字符。
				\item \textbf{int putchar(int var)}: 把字符输出到屏幕上，并返回相同的字符。同一时间只会输出一个单一的字符，可循环从而输出多个字符。
			\end{itemize}
			\subsection{gets() \& puts() 函数}
			\begin{itemize}
				\item \textbf{char $*$gets(char $*$ptr)}: 从stdin读取一行到ptr所指向的缓冲区，直到一个终止符或EOF。
				\item \textbf{int puts(const char $*$str)}：把字符串str 和一个尾随的换行符写入到stdout。
			\end{itemize}
			\subsection{scanf() 和 printf() 函数}
			\begin{itemize}
				\item \textbf{int scanf(const char $*$format,...)}：从标准输入流stdin读取输入，并根据提供的format来浏览输入。
				\item \textbf{int printf(const char $*$format,...)}把输出写入到标准输出流stdout, 并根据提供的格式产生输出。
				\item format是一个常量字符串，可以指定\%s, \%d, \%c, \%f 来输出或读取字符串，整数，字符或者浮点数。
				\item \textbf{scanf()}遇到一个空格就会停止读取。
			\end{itemize}
			\begin{framed}
				\textbf{NOTES:}\\
				\begin{enumerate}
					\item \textbf{gets() 与 fgets()}\\gets 函数原型：\emph{char $*$gets(char $*$buffer)};//读取字符到数组，\emph{gets(str);} str为数组。\\gets 函数功能：从键盘上输入字符，直到换行符或EOF时停止，并将读到的结果存放在\emph{buffer}指针指向的字符数组中。\\读取的换行符被转换为null值，作为字符数组的最后一个字符，来结束字符串。\\ \textbf{NOTE:}没有指定输入字符的大小，会无限读取，一旦输入的字符大于数组长度，就发生\underline{\textbf{内存越界}}\\fgets() 函数原型： \emph{char $*$fgets(char $*$s, int n, FILE $*$stream)}; //使用：\emph{fgets(str,sizeof(str),stdin)};\\其中str为数组首地址，sizeof(str)为数组大小，stdin为输入数据。\\ 功能：从文件指针stream中读取字符，存到以s为起始地址的空间内，直到读完n-1个字符，或读完一行。\\ \textbf{NOTE:}最多只能读入n-1个字符。读入结束后，自动在最后加上'\textbackslash0',并以str作为函数值返回。
					\item \textbf{Windows, Unix, Mac 不同系统的换行}\\ 换行符 '\textbackslash n': 另起一行；回车符 '\textbackslash r': 回到一行的开头。\\ 平时的回车符准确而言为 \textbf{\underline{回车换行符}}\\ MS-DOS 和 Windows中，使用'\textbackslash n'和'\textbackslash r'两个作为换行符，即'\textbackslash r \textbackslash n'；\\Unix和Mac每行结尾为'\textbackslash n'。
					\item \textbf{正则表达式控制输入格式为非空格非换行}: \\\emph{scanf("\%d\%[\^ \ ' ' \^ \ ' \textbackslash n ' ] ", \&i, \&c);}
					\item \textbf{输出实数的f格式符(小数形式)}：\\直接使用 \emph{\% f}; \\ 指定数据宽度和小数位数，用 \emph{\% m.nf}: 指定输出的数据占m位，其中包括n位小数。\\ 输出的数据向左对齐，用\emph{\% -m.nf}: 数据长度不长过m，数据向左对齐，右端补空格。
					\item \textbf{putchar}: 将一个字符赋给字符变量和将字符的ASCII代码赋给字符变量的作用一样。
					\item \textbf{scanf的返回值}：\\有返回值且类型为int型，发生错误时立即返回EOF。\\返回的值：正确按照指定格式输入变量的个数。
				\end{enumerate}
			\end{framed}

			\clearpage
			\section{C 文件读写}
			\subsection{打开文件}
			使用fopen() 函数创建或打开一个文件，会初始化类型FILE的一个对象。
			\begin{framed}
				FILE $*$fopen( const char $*$filename, const char $*$ mode);
			\end{framed}
			filename 为字符串，命名文件。访问模式从表~\ref{fopen访问模式} 选择。
			\begin{table}
				\caption{访问模式}\label{fopen访问模式}
				\begin{tabular}[]{l|p{28em}}
					\toprule
					模式&描述\\
					\midrule
					r&打开已有文件，允许读取文件。\\
					w&打开已有文件，截断为零长度，重新写入；或创建新文件，从头写入。\\
					a&打开或创建文件，以追加模式写入。\\
					r+&打开文件，允许读写文件。\\
					w+&打开已有文件，截断为零长度，或创建新文件，允许读写文件。\\
					a+&打开已有文件，允许读写；或创建新文件。读取从开头开始，写入为追加模式。\\
					\bottomrule
				\end{tabular}
			\end{table}
			\subsection{关闭文件}
			使用fclose()函数：
			\begin{framed}
				int fclose (FILE $*$fp);
			\end{framed}
			\subsection{写入文件}
			\begin{framed}
				int fputc (int c, FILE $*$fp);
			\end{framed}
			函数fputc()把参数c的字符值写入到fp所指向的输出流中。如果写入成功，会返回写入的字符；若发生错误，就返回EOF。\\
			可以使用下列函数把一个以null结尾的字符串写入流中：\begin{framed}
				int fputs( const char $*$s, FILE $*$fp);
			\end{framed}
			函数fputs()把字符串s写入到fp所指向的输出流中。若写入成功，则返回一个非负值。若错误，返回EOF。
			\subsection{读取文件}
			\begin{framed}
				int fgetc( FILE $*$fp);
			\end{framed}
			\textbf{fgetc()}函数从fp所指向的输入文件中读取一个字符。返回值为读取的字符，错误则返回EOF。\\
			下面能从流中读取一个字符串：\begin{framed}
				char $*$fgets(char $*$buf, int n, FILE $*$fp);
			\end{framed}
			\textbf{fgets()}函数从fp所指向的输入流中读取n-1个字符。他会把读取的字符串复制到缓冲区buf，并在最后追加一个null字符来终止字符串。\\
			这个函数在读取最后一个字符之前就遇到一个换行符'\textbackslash n'或文件末尾EOF，则只会返回读取到的字符，包括换行符。\\
			可使用 \textbf{int fscanf(FILR $*$fp, const char $*$format,...)}函数从文件中读取字符串，但是在遇到第一个空格字符时，它会停止读取。
			\subsection{二进制I/O函数}
			\begin{framed}
				size\_t fread (void $*$ptr, size\_t size\_of\_elements, size\_t, number\_of\_elements,FILE $*$a\_file);\\
				size\_t fwrite (const void $*$ptr, size\_t size\_of\_elements, size\_t number\_of\_elements, FILE $*$a\_file);
			\end{framed}
			\begin{framed}
				\textbf{NOTES:}\\
				\textbf{fseek}可以移动文件指针到指定位置读，或插入写。
				\begin{framed}
					int fseek(FILE $*$stream, long offset, int whence);
				\end{framed}
				fseek设置当前读写点到offset处，whence可以是SEEK\_SET, SEEK\_CUR, SEEK\_END 这些值决定是从\underline{文件头，当前点还是文件尾}计算偏移量offset。\\
				可以定义一个文件指针 \textbf{FILE $*$fp},当打开一个文件时，文件指针指向开头，通过控制偏移量决定指向。\\
				只有用\underline{r+}模式打开文件才能插入内容，\underline{w或w+}模式会清空原文件重写，\underline{a或a+}总会在文件最末尾添加内容。
			\end{framed}

			\clearpage
			\section{预处理器}
			预处理器是一个文本替换工具，指示编译器在实际编译之前完成所需的预处理，C 预处理器（C Preprocessor）简写为CPP。
			\begin{table}
				\caption{预处理器指令}
				\begin{tabular}[]{l|l}
					\toprule
					指令&描述\\
					\midrule
					\#define&定义宏\\
					\#include&包含一个源代码文件\\
					\#undef&取消已定义的宏\\
					\#ifdef&如果宏已经定义，则返回为真\\
					\#ifndef&如果宏没有定义，则返回为真\\
					\#if&如果给定条件为真，则编译下面代码\\
					\#else & \#if的替换方案\\
					\#elif & 如果前面的\#if 给定条件不为真，当前条件为真，则编译下面代码\\
					\textbackslash endif & 结束一个\#if...\#else 条件编译块\\
					\textbackslash error & 遇到标准错误时，输出错误消息\\
					\#pragma & 使用标准化方法，向编译器发布特殊的命令到编译器中\\
					\bottomrule
				\end{tabular}
			\end{table}
			\section{头文件}
			扩展名为.h的文件，包括C函数声明和宏定义，分为两种：自定义的头文件和编译器自带的头文件。\\
			使用\textbf{\#include}来引用。
			\subsection{引用头文件的语法}
			可以引用用户和系统的头文件：\begin{itemize}
				\item 引用系统的头文件：\begin{framed}
					\#include <file>
				\end{framed}在系统目录搜索名为file的文件。
				\item 引用用户头文件：\begin{framed}
					\#include "file"
				\end{framed}
			\end{itemize}
			\subsection{引用头文件的操作}
			\#include指令会指示C预处理器浏览指定的文件作为输入。预处理器的输出包括了已经生成的输出，被引用文件生成的输出以及\#include指令之后的文本输出。
			\begin{framed}
				头文件header.h: char $*$test (void);\\
				主程序:int x;\\
				\#include "header.h"\\
				int main (void)\\
				\{\\
					puts (test ());\\
				\}\\
			\end{framed}
			其中 \#include "header.h" -> char $*$test (void);
			\subsection{只引用一次头文件}
			如果一个头文件被引用两次，编译器会处理两次头文件，可能产生错误，避免这样的做法是：将文件的整个内容放在条件编译语句中。
			\begin{framed}
				\#ifndef HEADER\_FILE\\
				\#define HEADER\_FILE\\
				the entire header file \\
				\#endif\\
			\end{framed}当再次引用头文件时，条件为假，则预处理器会跳过文件的整个内容。
			\subsection{有条件引用}
			从多个不同的头文件中选择一个引用到程序中。\begin{framed}
				\#if SYSTEM\_1\\
				\# include "system\_1.h"\\
				\#elif SYSTEM\_2\\
				\# include "system\_2.h"\\
				\textbackslash elif SYSTEM\_3
				...\\
				\#endif\\
			\end{framed}
			\begin{framed}
				\textbf{NOTES:}\\
				\begin{itemize}
					\item 在有多个.h文件和多个.c文件的时候，可使用一个\textbf{global.h}的头文件来包括所有的.h文件，在除\textbf{global.h}文件外的头文件中包括\textbf{global.h}就可以实现所有头文件的包含。如：\begin{framed}
						\#ifndef \_GLOBAL\_H\\
						\#define \_GLOBAL\_H\\
						\#include <...>\\
						...\\
					\end{framed}
				\end{itemize}
			\end{framed}
			\section{强制类型转换}
			将变量从一个类型转换为另一个数据类型。可用来把值显式地从一个类型转换为另外一种类型。
			\begin{framed}
				(type\_name) expression
			\end{framed}
			\subsection{整数提升}
			把小于 int 或 unsigned int 的整数类型转换为 int 或 unsigned int 的过程。（字符转化为对应的asicii值）
			\subsection{常用的算术转换}
			隐式地把值强制转换到相同的类型，首先执行整数提升。如果操作数类型不同，则按照下式进行转换：\begin{align*}
				int& \rightarrow unsigned\ int \rightarrow long \rightarrow unsigned\ long \\ &\rightarrow long\ long \rightarrow unsigend\ long\ long \rightarrow float \rightarrow double \rightarrow long\ double
			\end{align*}

			\clearpage
			\section{错误处理}
			以返回值的形式访问底层数据，发生错误返回1或者NULL，同时设置一个错误代码errno，其为全局变量，表示在函数调用期间发生了错误。
			\subsection{errno,perror()和strerror()}
			\begin{itemize}
				\item \textbf{perror()}函数显示用户传的字符串，后跟一个冒号、一个空格和当前errno值的文本表示形式。
				\item \textbf{strerror()}函数，返回一个指针，指针指向当前errno值的文本表现形式
			\end{itemize}
			\subsection{被零除的错误}
			\begin{framed}
				if (divisor == 0){\\
					frprint(stderr,"The divisor is 0 and the programm will be exited\textbackslash n");\\
					exit(-1);\\
				}
			\end{framed}
			\subsection{程序退出状态}
			通常情况下，正常退出会带值EXIT\_SUCCESS。其为宏，通常被定义为0；若出现错误，退出程序时值为-1。
			
			\clearpage
			\section{递归}
			指函数定义中使用函数自身的方法。\\
			语法格式：
			\begin{framed}
				void recursion()\\
				\{\\
					statements;\\
					...\\
					recursion();\\
					...\\
				\}\\
				int main()
				\{\\
					recursion();\\
				\}
			\end{framed}
			\textbf{NOTE:}注意定义一个从函数退出的条件，防止进入死循环。
			\subsection{数的阶乘}
			\begin{framed}
				double factorial (unsigned int i)\\
				\{\\
					if (i <= 1)\\
					\{\\
						return 1;\\	
					\}\\
					return i $*$ factorial(i-1);\\
				\}\\
			\end{framed}
			\subsection{斐波那契数列}
			\begin{framed}
				int fibonaci(int i)\\
				if (i == 0 )\\
				\{\\
					return 0;\\
				\}\\
				if(i == 1)\\
				\{\\
					return 1;\\
				\}\\
				return fibonaci(i-1)+fibonaci(i-2);\\
			\end{framed}
			\begin{framed}
				\textbf{NOTES:}\\
				\begin{itemize}
					\item 递归函数会耗费更多的运行时间，占用大量的栈空间，每次递归时需要把它的状态存到栈中。
					\item \textbf{使用递归的三个条件：}\begin{enumerate}
						\item 可以把要解决的问题转换为一个新的问题，而新问题的解决方法任然与原来的解决方法相同，只是处理的对象有规律地递增或递减。
						\item 可以应用这个转换过程使问题得到解决。
						\item 必定有个明确的结束递归的条件。
					\end{enumerate}
				\end{itemize}
			\end{framed}
			
			\clearpage
			\section{可变参数}
			对于函数带有可变数量的参数，而不是预定义数量的参数。可变参数允许根据需求接受可变数量的参数，示例：\begin{framed}
				int func(int, ...)\\
				\{\\
					...\\
				\}\\
				int main()\\
				\{\\
					func(...)\\
				\}\\
			\end{framed}
			func()函数最后参数写成省略号，省略号之前的那个参数代表要传递的可变参数的总数。需要使用\underline{stdarg.h}头文件。具体步骤如下：\begin{itemize}
				\item 定义一个函数，最后一个参数为省略号，省略号之前可以设置自定义参数。
				\item 在函数定义中创建一个\textbf{va\_list}类型变量，该类型是在\underline{stdarg.h}头文件中定义的。
				\item 使用 int 参数和 \textbf{va\_start}宏来初始化\textbf{va\_list}变量为一个参数列表。宏\textbf{va\_start}是在\textbf{stdarg.h}头文件中定义的。
				\item 使用\textbf{va\_arg}宏和\textbf{va\_list}变量来访问参数列表中的每个项。
				\item 使用\textbf{va\_end}来清理赋予\textbf{va\_list}变量的内存。
			\end{itemize}
			\begin{framed}
				double func(int num, ...)\\
				\{\\
					va\_list valist;\\
					va\_start(valist, num);\textbackslash\textbackslash 初始化\\
					va\_arg(valist, int);\textbackslash\textbackslash 访问参数
					va\_end(valist);\\ \textbackslash\textbackslash 清理内存\\ 
				\}\\
			\end{framed}
			\begin{framed}
				\textbf{NOTES:}\\
				\begin{itemize}
					\item \textbf{可变参数的工作原理}：\begin{itemize}
						\item 函数的参数的传递存储在栈中，从右至左压入栈中，压栈过程为递减。
						\item 参数的传递以4字节对齐。
					\end{itemize}
					\item 可变参数中使用的宏：\begin{framed}
						void va\_start(va\_list arg\_ptr, prev\_param);\\
						type va\_arg(va\_list arg\_ptr, type);\\
						void va\_end (va\_list arg\_ptr);
					\end{framed}
					\item va\_list:用来保存宏va\_start, va\_arg和va\_end 所需信息的一种类型。为了访问变长参数列表中的参数，必须声明va\_list 类型的一种对象，定义：typedef char$*$va\_list;\\va\_start:访问变长参数列表中的参数之前使用的宏，初始化va\_list声明的对象，初始化结果供va\_arg 和va\_end 使用。\\va\_arg:展开成一个表达式的宏，该表达式具有变长参数列表中下一个参数的值和类型。每次调用va\_arg都会修改用va\_list声明的对象，从而使该对象指向参数列表中的下个参数。\\ va\_end:该宏使程序能够从变长参数列表用宏va\_start引用的函数中正常返回。\\这些宏定义在stdarg.h中，使用时需要包含在这个头文件中。
				\end{itemize}
			\end{framed}
			
			\clearpage
			\section{命令行参数}
			从命令行传值给C程序。这些值被称为\textbf{命令行参数}。\\
			使用main()函数参数来处理的，其中\textbf{argc}是指传入参数的个数，\textbf{argc[]}是一个指针数组，指向传递程序中的每个参数。\\
			\textbf{argv[0]}存储程序的名称，\textbf{argv[1]}是一个指向第一个命令行参数的指针，$*$argv[n]是最后一个参数。\\
			多个命令行参数之间用空格分隔，如果参数自身带有空格，则传递参数的时候应把参数放置在双引号“”或单引号’‘内部。
	\end{document}